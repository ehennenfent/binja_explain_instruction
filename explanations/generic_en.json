{
  "LLIL_SET_REG": "Sets {llil.dest} to {llil.src}",
  "LLIL_PUSH": "Decrements the stack pointer by {llil.size}, then writes the value of {llil.src} onto the stack.",
  "LLIL_CALL": "Calls the function at {llil.dest}",
  "LLIL_STORE": "Copies {llil.src} into memory at address {llil.dest} ({llil.size} bytes)",
  "LLIL_RET": "Pops the return pointer off the stack and jumps to that address.",
  "LLIL_NOP": "No Operation",
  "LLIL_GOTO": "Jumps to the instruction at {dest}",
  "LLIL_JUMP": "Jumps to the instruction at {llil.dest}",
  "LLIL_IF": "Jumps to {true} if the CPU flags indicate that {llil.condition}, otherwise, falls through to {false}",
  "LLIL_LOAD": "the {llil.size} bytes of memory starting at {llil.src}",
  "LLIL_UNIMPL": "Binja doesn't understand this instruction yet. Please consult the architecture documentation.",
  "LLIL_UNIMPL_MEM": "Binja doesn't understand this instruction yet. Please consult the architecture documentation.",
  "LLIL_UNDEF": "This instruction is undefined in Binary Ninja's Low-Level Intermediate Language.",
  "LLIL_REG": "{source}{location}",
  "LLIL_ADD": "{llil.left} + {llil.right}",
  "LLIL_SUB": "{llil.left} - {llil.right}",
  "LLIL_SBB": "{llil.left} - ({llil.right} + CarryFlag)",
  "LLIL_ADC": "{llil.left} + {llil.right} + CarryFlag",
  "LLIL_MUL": "{llil.left} * {llil.right}",
  "LLIL_MULU_DP": "{llil.left} * {llil.right} (unsigned, double precision)",
  "LLIL_MULS_DP": "{llil.left} * {llil.right} (signed, double precision)",
  "LLIL_DIVU": "{llil.left} / {llil.right} (unsigned)",
  "LLIL_DIVU_DP": "{llil.hi}:{llil.lo} / {llil.right} (unsigned)",
  "LLIL_DIVS": "{llil.left} / {llil.right} (signed)",
  "LLIL_DIVS_DP": "{llil.hi}:{llil.lo} / {llil.right} (signed)",
  "LLIL_MODU": "{llil.left} % {llil.right} (unsigned)",
  "LLIL_MODU_DP": "{llil.hi}:{llil.lo} % {llil.right} (unsigned)",
  "LLIL_MODS": "{llil.left} % {llil.right} (signed)",
  "LLIL_MODS_DP": "{llil.hi}:{llil.lo} % {llil.right} (signed)",
  "LLIL_AND": "{llil.left} & {llil.right}",
  "LLIL_OR": "{llil.left} | {llil.right}",
  "LLIL_XOR": "{llil.left} ^ {llil.right}",
  "LLIL_LSL": "{llil.left} << {llil.right}",
  "LLIL_LSR": "{llil.left} >> {llil.right} (logical)",
  "LLIL_ASR": "{llil.left} >> {llil.right} (arithmetic)",
  "LLIL_ROL": "{llil.left}, rotated {llil.right} bits to the left",
  "LLIL_RLC": "{llil.left}, rotated-with-carry {llil.right} bits to the left",
  "LLIL_ROR": "{llil.left}, rotated {llil.right} bits to the right",
  "LLIL_RRC": "{llil.left}, rotated-with-carry {llil.right} bits to the right",
  "LLIL_CONST": "{constant}",
  "LLIL_ZX": "{llil.size} zero-extended bytes from {llil.src}",
  "LLIL_SX": "{llil.size} sign-extended bytes from {llil.src}",
  "LLIL_NORET": "(Does not return)",
  "LLIL_POP": "the {llil.size} bytes at the top of the stack, then increments the stack pointer by {llil.size}.",
  "LLIL_CMP_E": "{llil.left} == {llil.right}",
  "LLIL_CMP_NE": "{llil.left} != {llil.right}",
  "LLIL_CMP_SLT": "{llil.left} < {llil.right} (signed)",
  "LLIL_CMP_ULT": "{llil.left} < {llil.right} (unsigned)",
  "LLIL_CMP_SLE": "{llil.left} <= {llil.right} (signed)",
  "LLIL_CMP_ULE": "{llil.left} <= {llil.right} (unsigned)",
  "LLIL_CMP_SGE": "{llil.left} >= {llil.right} (signed)",
  "LLIL_CMP_UGE": "{llil.left} >= {llil.right} (unsigned)",
  "LLIL_CMP_SGT": "{llil.left} > {llil.right} (signed)",
  "LLIL_CMP_UGT": "{llil.left} > {llil.right} (unsigned)",
  "LLIL_SYSCALL": "Performs a system call",
  "LLIL_NEG": "-1 * {llil.src} (2's compliment)",
  "LLIL_NOT": "the bitwise inverse of {llil.src}",
  "LLIL_SET_REG_SPLIT": "Gets {llil.src} and stores the result in {llil.hi}:{llil.lo} (hi:lo)",
  "LLIL_CONST_PTR": "{constant}",
  "LLIL_EXTERN_PTR": "external pointer at {llil.constant}+{llil.offset}",
  "LLIL_TRAP": "Halts the CPU until the next interrupt is fired.",
  "LLIL_BP": "Processor Breakpoint",
  "LLIL_FLAG_COND": "the last comparison was {condition}",
  "LLIL_BOOL_TO_INT": "<NOT IMPLEMENTED> Converts boolean value in {llil.src} to an integer",
  "LLIL_JUMP_TO": "Jump Table: Jumps to the instruction at the address given by {llil.dest}",
  "LLIL_FLAG": "{llil.src} (at instruction {llil.address})",
  "LLIL_SET_FLAG": "set temporary flag {llil.dest} to {llil.src}",
  "LLIL_FLAG_BIT": "bit {llil.bit} of flag {llil.src}",
  "LLIL_TEST_BIT": "{llil.left} bitwise compared with {llil.right}",
  "LLIL_LOW_PART": "the low {llil.size} bytes of memory at {llil.src}",
  "LLIL_ADD_OVERFLOW": "<NOT IMPLEMENTED> Adds {llil.left} and {llil.right} with overflow",
  "LLIL_INT_TO_FLOAT":  "{llil.src} converted to a float",
  "LLIL_FLOAT_TO_INT":  "{llil.src} converted to an int",
  "LLIL_ROUND_TO_INT":  "{llil.src} rounded to the nearest integer",
  "LLIL_CEIL": "ceiling({llil.src})",
  "LLIL_FLOOR": "floor({llil.src})",
  "LLIL_FABS": "the absolute value of {llil.src}",
  "LLIL_FADD": "{llil.left} + {llil.right} (as floats)",
  "LLIL_FSUB": "{llil.left} - {llil.right} (as floats)",
  "LLIL_FMUL": "{llil.left} * {llil.right} (as floats)",
  "LLIL_FDIV": "{llil.left} / {llil.right} (as floats)",
  "LLIL_FCMP_E": "{llil.left} == {llil.right} (as floats)",
  "LLIL_FCMP_GE": "{llil.left} >= {llil.right} (as floats)",
  "LLIL_FCMP_GT": "{llil.left} > {llil.right} (as floats)",
  "LLIL_FCMP_LE": "{llil.left} <= {llil.right} (as floats)",
  "LLIL_FCMP_LT": "{llil.left} < {llil.right} (as floats)",
  "LLIL_FCMP_NE": "{llil.left} != {llil.right} (as floats)",
  "LLIL_FLOAT_CONST": "floating point constant {llil.constant}",
  "LLIL_FNEG": "-1 * {llil.src} (floating point)",
  "LLIL_FSQRT": "the square root of {llil.src}",
  "LLIL_FTRUNC": "{llil.src} (truncated)",
  "LLIL_TAILCALL": "Calls {llil.dest} with {llil.params} as input and returns to {llil.output}",
  "LLFC_E": "equal",
  "LLFC_NE": "not equal",
  "LLFC_SLT": "signed less than",
  "LLFC_ULT": "unsigned less than",
  "LLFC_SLE": "signed less than or equal",
  "LLFC_ULE": "unsigned less than or equal",
  "LLFC_SGE": "signed greater than or equal",
  "LLFC_UGE": "unsigned greater than or equal",
  "LLFC_SGT": "signed greather than",
  "LLFC_UGT": "unsigned greater than",
  "LLFC_NEG": "negative",
  "LLFC_POS": "positive",
  "LLFC_O": "overflow",
  "LLFC_NO": "no overflow"
}
